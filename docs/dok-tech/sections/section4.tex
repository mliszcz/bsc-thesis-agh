\section{Technologie}
Niniejszy rozdział opisuje szczegóły techniczne organizacji projektu, kompilacji kodu źródłowego i uruchamiania zbudowanej aplikacji.

\subsection{Struktura projektu}
W głównym katalogu repozytorium znajduje się wiele folderów i plików.

Katalogi:
\begin{itemize}
	\item benchmark/ - testy wydajnościowe, napisane w Erlangu wykonujące dużą ilość zapytań w systemie i mierzące czas obsługi. Testy uruchamiane są poprzez skrypty bash.
	\item clustertool/ - dwa skrypty: make\_cluster.sh pozwalający na wygenerowanie klastra o dowolnej konfiguracji oraz cluster.sh służący do zarządzania klastrem / węzłem działającym na lokalnej maszynie
	\item curl/ - implementacja metod PUT (put.sh), POST (post.sh) i DELETE (delete.sh) przy pomocy programu curl. Sumy HMAC wyliczane są przez openssl-client
	\item erlang-sqlite/ - sterownik bazy danych
	\item storage/ - właściwy kod źródłowy aplikacji Erlang/OTP
\end{itemize}

Pliki:
\begin{itemize}
	\item rebar – skrypt używany do budowania aplikacji
	\item Makefile – makefile będący nakładką na rebara. Interesujące cele: all, release
	\item env\_server.sh – skrypt uruchamiający interpreter języka Erlang i ładujący wszystkie skompilowane moduły. Aplikację można uruchomić wpisując:
	
	application:start(sqlite3).
	application:start(storage).
	\item env\_test.sh – skrypt uruchamiający interpreter z załadowaną bibiloteką kliencką
	\item node.config – plik z konfiguracją budowanego węzła. Więcej szczegółów w rozdziale 4.5 Pliki konfiguracyjne
	\item node.config.template – plik z ustawieniami referencyjnymi
	\item setup-rhel.sh – skrypt konfigurujący repozytorium i środowisko w systemach RedHat. Można również zobaczyć jak należy ustawiać parametry do komunikacji węzłów w sieci Internet.
	\item test.config(.template) – odpowiednik node.config dla benchmarków
\end{itemize}

\paragraph{Właściwa aplikacja} Źródła aplikacji znajdują się w katalogu storage/. Struktura podkatalogów przedstawia się następująco:
\begin{itemize}
	\item include/shared.hrl – definice rekordów i makr
	\item priv/manager.html – web-gui
	\item rel/ - konfiguracja reltoola i miejsce generowania releasa
	\item src/ - pliki źródłowe
	\begin{itemize}
		\item auth/ – moduł autentykacji
		\item client/ - moduł biblioteki klienckiej
		\item core/ - moduł wykonawczy
		\item dist/ - moduł komunikacyjny
		\item http/ - moduł HTTP
		\item shared/ - współdzielone moduły
	\end{itemize}
	\item test/accept.sh – testy akceptacyjne
\end{itemize}


\subsection{rebar}
rebar jest narzędziem wykorzystywanym do budowania aplikacji. Jest to samodzielny skrypt, konfigurowalny przez pliki rebar.config (zawierające struktury języka Erlang) znajdujące się w katalogu głównym i podkatalogach.

W głównym katalogu znajduje się plik rebar.config o następującej treści:

{sub\_dirs, ["storage", "benchmark"] }.

Oznacza to że w te dwa katalogi zostaną przeszukane podczas kompilacji projektu.


\subsection{Kompilacja}
Plik storage/rebar.config ma następującą zawartość:
\begin{lstlisting}
{sub_dirs, ["rel"]}.

{erl_opts, [

	% compile-time options (no'opt' disables option, e.g. nolog)
	{d, log}, 			% enable logger
	{d, auth}, 			% authenticate requests
	{d, fileio}, 		% read / write real files
	{d, actionlog}, 	% track and log user actions
	{d, persistentdb}, 	% disk / memory db
	{d, noprofile}, 	% run with fprof profiler

	{i, "include"},
	{src_dirs, [
		"src",
		"src/shared",
		"src/core",
		"src/client",
		"src/dist",
		"src/http"
	]}
]}.
\end{lstlisting}

Pierwsza linia mówi, że należy przeszukać podkatalog rel/. Znajduje się tam konfiguracja innego narzędzia, reltoola, uruchamianego poleceniem ./rebar generate, tworzącego samodzielny release.

Następnie definiowany jest szereg flag, które blokują bądź odblokowują pewne funkcje systemu (najczęściej zdefiniowane w postaci makr zależnych od wyżej wymienionych symboli). Dostępne opcje:
\begin{itemize}
	\item log / nolog – włączenie / wyłączenie loggera
	\item auth / noauth – włączenie / wyłączenie autentykacji zapytań (przydatne do testów kiedy nie mamy możliwości wyliczenia sumy HMAC)
	\item fileio / nofileio – wykonywane / pomijane operacje na fizycznych plikach (zapisy są ignorowane, przy odczycie zwracana jest pusta zawartość)
	\item actionlog / noactionlog – włączenie / wyłączenie logowania zachodzących akcji do bazy danych
	\item persistentdb / nopersistentdb – baza zapisywana na dysku / działająca w trybie in-memory.
	\item profile / noprofile – urchom razem z profilerem
\end{itemize}

Ostatnia sekcja definiuje położenie plików źródłowych.




\subsection{Testy akceptacyjne}
Testy akceptacyjne zawarte są w skrypcie storage/test/accept.sh. Testowany jest następujący scenariusz:
\begin{itemize}
	\item POST - utworzenie pliku o rozmiarze 128 MB (z losową zawartością)
	\item GET – pobranie utworzonego pliku, porównanie bajt po bajcie
	\item PUT – aktualizacja pliku losowymi danymi o rozmiarze 256 MB
	\item GET - pobranie utworzonego pliku, porównanie bajt po bajcie
	\item DELETE – usunięcie utworzonego pliku, oczekiwana odpowiedź: 202 Accepted
	\item GET – pobranie usuniętego pliku, oczekiwana odpowiedź: 404 Not Found
\end{itemize}

Test komunikuje się z systemem poprzez protokół HTTP. Należy znać więc adres na jakim nasłuchuje moduł storage\_http\_srv. Wtedy test można uruchomić tak:

./accept.sh localhost:8090

Skrypt do uruchomienia wymaga narzędzi curl (komunikacja HTTP) i openssl-client (suma HMAC, generowanie losowych plików).


\subsection{Pliki konfiguracyjne}
Podstawowym plikiem konfiguracyjnym jest node.config umieszczony w głównym katalogu projektu. Przykładowa zawartośc:
\begin{lstlisting}
{app_log_level, info}.

{core_work_dir, "/home/michal/Documents/inz/work_dir"}.
{core_storage_quota,	1073741824}.
{core_memory_quota,		134217728}.

{dist_initial_node, "ds@michal-pc"}.

{uuid_interface_name, "eth0"}.

{http_port, 8090}.
\end{lstlisting}

Dostępne parametry to:
\begin{itemize}
	\item app\_log\_level – poziom szczegółowości komunikatów loggera. Dostępne wartości: info, warn, error oraz none
	\item core\_work\_dir – fizyczna lokalizacja gdzie będą przechowywane pliki użytkowników i baza danych 
	\item core\_storage\_quota – dostępne zasoby dyskowe, w bajtach (maksymalna pojemność węzła)
	\item core\_memory\_quita – dostępna pamięć ram, w bajtach (przy przekroczeniu tej wartości zostawał uruchomiony gabage collector, obecnie nieużywane)
	\item dist\_initial\_node – adres początkowego węzła, który posłuży do inicjalizacji aktualnego. Procedura opisana jest w punkcie 3.2.1  Dołączanie węzłów.
	\item uuid\_interface\_name – nazwa interfejsu sieciowego z którego pobrany zostanie adres MAC wykorzystywany przez generator identyfikatorów
	\item http\_port – port na jakim nasłuchuje moduł HTTP
\end{itemize}

W czasie generowania releasa, plik ustawień zostanie dołączony do wynikowej paczki.



\subsection{Zarządzanie klastrem}
Klaster to kilka połączonych węzłów współpracujących ze sobą. Klaster można wygenerować przy użyciu skryptu clustertool/make\_cluster.sh. Wytworzy on we wskazanym folderze podfoldery ds1, ds2, …, z odpowiednio ustawionymi initial node oraz portami. Następnie można przenieść je na docelowe maszyny i uruchomić przy użyciu narzędzia clustertool/cluster.sh.
Procedury te opisuje dokumentacja administratora.
